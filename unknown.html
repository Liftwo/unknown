<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>æœªçŸ¥ Unknown éŠæˆ²</title>
  <style>
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f5f5f5;
    }
    .board {
      display: grid;
      grid-template-columns: repeat(17, 40px);
      grid-template-rows: repeat(17, 40px);
      gap: 2px;
      margin-bottom: 1rem;
    }
    .cell {
      width: 40px;
      height: 40px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 12px;
      font-weight: bold;
      color: #000;
      border: 1px solid #ccc;
      position: relative;
    }
    .cell.empty {
      visibility: hidden;
    }
    .controls {
      margin-bottom: 1rem;
    }
    .playerCube {
      font-size: 10px;
      position: absolute;
      bottom: 0;
      left: 0;
      background: rgba(255,255,255,0.7);
      padding: 1px;
    }
    #turnInfo {
      margin-top: 10px;
      font-weight: bold;
      font-size: 16px;
      color: #333;
    }
    .null { background-color: transparent; border: none; }
    .gray { background-color: #ccc; }
    .white { background-color: #fff; }
    .red { background-color: #EE4B2B; }
    .green { background-color: #6f6; }
    .blue { background-color: #0096FF; }
    .yellow { background-color: #ff6; }
    .purple { background-color: #c6f; }
    .pink { background-color: #f6c; }
    .lightblue { background-color: #6ff; }
    .orange { background-color: #fa3; }
    .black { background-color: #000; color: #fff; }
  </style>
</head>
<body>
  <h1>æœªçŸ¥ Unknown éŠæˆ²</h1>

  <div class="controls">
    <label>é¸æ“‡ç©å®¶ï¼š</label>
    <select id="playerSelect"></select>
    <label>èµ·å§‹æ ¼å­è™Ÿç¢¼ï¼š</label>
    <input type="number" id="startNumber" min="1" max="104" style="width: 60px;">
    <label>é ‚é¢é¡è‰²ï¼š</label>
    <select id="startTop">
      <option value="blue">è—</option>
      <option value="red">ç´…</option>
      <option value="green">ç¶ </option>
      <option value="yellow">é»ƒ</option>
      <option value="purple">ç´«</option>
      <option value="white">ç™½</option>
    </select>
    <button onclick="setPlayerStart()">è¨­å®š</button>
  </div>

  <div>
    <button onclick="move('up')">ä¸Š</button>
    <button onclick="move('down')">ä¸‹</button>
    <button onclick="move('left')">å·¦</button>
    <button onclick="move('right')">å³</button>
  </div>

  <div id="diceGuide" style="margin: 10px; padding: 10px; border: 1px solid #ccc; background: #fff; font-size: 14px;">
  ğŸ² éª°å­å…­é¢é¡è‰²é †åºï¼š<br>
  <strong>ä¸Šï¼š</strong> è— (blue)ï¼Œ<strong>ä¸‹ï¼š</strong> ç™½ (white)ï¼Œ<strong>å·¦ï¼š</strong> ç´… (red)ï¼Œ
  <strong>å³ï¼š</strong> ç´« (purple)ï¼Œ<strong>å‰ï¼š</strong> ç¶  (green)ï¼Œ<strong>å¾Œï¼š</strong> é»ƒ (yellow)<br>
  <em>åˆå§‹é ‚é¢é¡è‰²æœƒå½±éŸ¿å…¶é¤˜äº”é¢çš„ä½ç½®</em>
  </div>

  <div class="board" id="board"></div>
  <div id="turnInfo"></div>

  <script>
    const boardData = [...];
    const colorMap = {...}; // unchanged

  const players = [
    { id: 1, name: "ç©å®¶1", x: undefined, y: undefined, cube: null, ready: false, banCount: 0, isBanished: false },
    { id: 2, name: "ç©å®¶2", x: undefined, y: undefined, cube: null, ready: false, banCount: 0, isBanished: false },
    { id: 3, name: "ç©å®¶3", x: undefined, y: undefined, cube: null, ready: false, banCount: 0, isBanished: false },
    { id: 4, name: "ç©å®¶4", x: undefined, y: undefined, cube: null, ready: false, banCount: 0, isBanished: false },
  ];

    let currentPlayerIdx = 0;

  function createCube(topColor, facing = "front") {
    const baseCube = {
      top: topColor,
      bottom: "white",
      front: "blue",
      back: "yellow",
      left: "red",
      right: "green",
      facing: facing
    };
    return baseCube;
  }


    function findPositionByNumber(n) {
      for (let y = 0; y < boardData.length; y++) {
        for (let x = 0; x < boardData[y].length; x++) {
          if (boardData[y][x] === n) return { x, y };
        }
      }
      return null;
    }

    function allPlayersReady() {
      return players.every(p => p.ready);
    }
    function setPlayerStart() {
      const playerIdx = parseInt(document.getElementById("playerSelect").value);
      const startNumber = parseInt(document.getElementById("startNumber").value);
      const topColor = document.getElementById("startTop").value.toLowerCase();

      const facing = prompt("è«‹è¼¸å…¥ä½ çš„è‡‰æœå‘ï¼ˆfront / back / left / rightï¼‰ï¼š").toLowerCase();
      const validColors = ["blue", "red", "green", "yellow", "purple", "white"];
      const validFacings = ["front", "back", "left", "right"];

      if (!validColors.includes(topColor)) {
        alert("ç„¡æ•ˆé ‚é¢é¡è‰²ï¼");
        return;
      }

      if (!validFacings.includes(facing)) {
        alert("ç„¡æ•ˆè‡‰æœå‘ï¼");
        return;
      }

      const pos = findPositionByNumber(startNumber);
      if (!pos) {
        alert("ç„¡æ•ˆæ ¼å­è™Ÿç¢¼");
        return;
      }

      const cellColor = colorMap[startNumber];
      if (cellColor !== "gray") {
        alert("åªèƒ½å¾ç°è‰²æ ¼å­èµ·å§‹");
        return;
      }

      const player = players[playerIdx];
      player.x = pos.x;
      player.y = pos.y;
      player.cube = createCube(topColor, facing);
      player.ready = true;
      drawBoard();

      if (allPlayersReady()) {
        currentPlayerIdx = 0;
        updateTurnInfo();
        alert("æ‰€æœ‰ç©å®¶å·²æº–å‚™å®Œæˆï¼Œè¼ªåˆ°ã€Œ" + players[currentPlayerIdx].name + "ã€é–‹å§‹ç§»å‹•ã€‚");
      }
      console.log("ç›®å‰ç©å®¶æº–å‚™ç‹€æ…‹ï¼š", players.map(p => p.ready));

    }


    function rotateCube(cube, dir) {
      const { top, bottom, left, right, front, back, facing } = cube;
      let newCube = { ...cube };

      switch (dir) {
        case "up":
          newCube.top = front;
          newCube.front = bottom;
          newCube.bottom = back;
          newCube.back = top;
          break;
        case "down":
          newCube.top = back;
          newCube.back = bottom;
          newCube.bottom = front;
          newCube.front = top;
          break;
        case "left":
          newCube.top = right;
          newCube.right = bottom;
          newCube.bottom = left;
          newCube.left = top;
          break;
        case "right":
          newCube.top = left;
          newCube.left = bottom;
          newCube.bottom = right;
          newCube.right = top;
          break;
      }

      return newCube;
    }


    function checkRule1(player) {
      const posColor = colorMap[boardData[player.y][player.x]];
      if (player.cube.top === "white" || posColor === "white") {
        player.banCount++;
        player.isBanished = true;
        alert(`${player.name} å› ç‚ºé ‚é¢æˆ–æ ¼å­ç‚ºç™½è‰²ï¼Œè¢«æ”¾é€ï¼ç´¯ç© ${player.banCount} æšæ”¾é€æ¨™è¨˜ã€‚`);

        let grayChoices = [];
        for (let y = 0; y < 17; y++) {
          for (let x = 0; x < 17; x++) {
            const num = boardData[y][x];
            if (num && colorMap[num] === "gray") {
              grayChoices.push({ x, y, num });
            }
          }
        }

        if (grayChoices.length > 0) {
          const grayStr = grayChoices.map(c => `æ ¼å­ ${c.num} (${c.x},${c.y})`).join("");
          const selectedNum = prompt(`${player.name} è¢«æ”¾é€ï¼è«‹è¼¸å…¥ä½ æƒ³è¿”å›çš„ç°è‰²æ ¼å­ç·¨è™Ÿï¼š
    ${grayStr}`);
          const chosen = grayChoices.find(c => c.num == selectedNum);

          if (chosen) {
            const topColor = prompt("è«‹è¼¸å…¥æ–°çš„é ‚é¢é¡è‰²ï¼ˆè‹±æ–‡ï¼šblue, red, green, yellow, purple, whiteï¼‰");
            const validColors = ["blue", "red", "green", "yellow", "purple", "white"];
          if (!validColors.includes(topColor)) {
            alert("è¼¸å…¥éŒ¯èª¤ï¼Œè«‹è¼¸å…¥æœ‰æ•ˆçš„é¡è‰²ï¼ˆblue, red, green, yellow, purple, whiteï¼‰");
            return;
          }
          player.x = chosen.x;
          player.y = chosen.y;
          player.cube = createCube(topColor);
          player.justBanished = true;
          player.isBanished = false;
          alert(`${player.name} è¿”å›ç°è‰²æ ¼ ${selectedNum}ï¼Œæ–°é ‚é¢é¡è‰²ç‚º ${topColor}`);
          drawBoard();

          } else {
            alert("è¼¸å…¥ç„¡æ•ˆï¼Œæœªæ›´æ›ä½ç½®ã€‚");
          }
        }
      }
    }


    function checkRule4And5(player) {
  const x = player.x;
  const y = player.y;
  const myColor = player.cube.top;
  const boardColors = [];

  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      const nx = x + dx;
      const ny = y + dy;
      if (nx >= 0 && nx < 17 && ny >= 0 && ny < 17) {
        const num = boardData[ny][nx];
        if (num !== null && colorMap[num]) {
          boardColors.push(colorMap[num]);
        }
      }
    }
  }

  // ä¸å«è‡ªå·±é ‚é¢é¡è‰²çš„æƒ…æ³ä¸‹ï¼Œæ‰éœ€è¦æ›è‰²
  if (!boardColors.includes(myColor)) {
    const possible = Array.from(new Set(boardColors)).filter(color => color !== myColor && color !== "gray");
    if (possible.length > 0) {
      const colorNameMap = {
        blue: 'è—', red: 'ç´…', green: 'ç¶ ', yellow: 'é»ƒ', purple: 'ç´«', white: 'ç™½'
      };
      let promptStr = `${player.name} ä¹å®®æ ¼å…§ç„¡èˆ‡é ‚é¢ç›¸åŒçš„æ£‹ç›¤é¡è‰²ï¼Œè«‹è¼¸å…¥æ–°çš„é ‚é¢é¡è‰²ï¼ˆè‹±æ–‡ï¼‰ï¼š
`;
      promptStr += possible.map(c => `- ${colorNameMap[c] || c} (${c})`).join("");
      const choice = prompt(promptStr);
      if (choice && possible.includes(choice.toLowerCase())) {
        player.cube.top = choice.toLowerCase();
        alert(`${player.name} é ‚é¢é¡è‰²æ›´æ›ç‚º ${choice}`);
      } else {
        alert("è¼¸å…¥éŒ¯èª¤ï¼Œç¶­æŒåŸé ‚é¢");
      }
    }
  }

}

function checkRule6(player) {
  const x = player.x;
  const y = player.y;
  const color = player.cube.top;
  let count = 0;

  // æª¢æŸ¥å‘¨åœ 3x3 æ ¼å­ä¸­ç›¸åŒé¡è‰²çš„æ•¸é‡
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      const nx = x + dx;
      const ny = y + dy;
      if (nx >= 0 && nx < 17 && ny >= 0 && ny < 17) {
        if (dx === 0 && dy === 0) continue; // âœ… ä¸åŒ…å«è‡ªå·±æ‰€åœ¨æ ¼
        const num = boardData[ny][nx];
        if (num !== null && colorMap[num] === color) {
          count++;
        }
      }
    }
  }

  // åŒ…å«è‡ªå·±çš„é ‚é¢é¡è‰²ï¼Œæ‰€ä»¥ count+1 >= 3
  if (count + 1 >= 3) {
    const candidateList = players.filter(p => p !== player);
    if (candidateList.length === 0) return;

    const nameList = candidateList.map((p, i) => `${i + 1}: ${p.name}`).join("\n");
    const choiceIdx = prompt(`${player.name} è§¸ç™¼ç¬¬å…­æ¢è¦å‰‡ï¼šè«‹é¸æ“‡ä¸€ä½è¦å¼·åˆ¶ç§»å‹•çš„ç©å®¶ï¼š\n${nameList}`);
    const idx = parseInt(choiceIdx);
    const target = candidateList[idx - 1];
    if (!target) {
      alert("è¼¸å…¥éŒ¯èª¤ï¼Œæœªé¸æ“‡ä»»ä½•ç©å®¶");
      return;
    }

    const dirInput = prompt("è«‹è¼¸å…¥è¦ç§»å‹•çš„æ–¹å‘ï¼ˆä¸Š: up, ä¸‹: down, å·¦: left, å³: rightï¼‰ï¼š");
    const dirMap = {
      up: { dx: 0, dy: -1 },
      down: { dx: 0, dy: 1 },
      left: { dx: -1, dy: 0 },
      right: { dx: 1, dy: 0 }
    };
    const dir = dirMap[dirInput];
    if (!dir) {
      alert("è¼¸å…¥æ–¹å‘éŒ¯èª¤ï¼Œæœªç§»å‹•");
      return;
    }

    const nx = target.x + dir.dx;
    const ny = target.y + dir.dy;
    if (
      nx >= 0 && nx < 17 && ny >= 0 && ny < 17 &&
      boardData[ny][nx] !== null &&
      !players.some(p => p.x === nx && p.y === ny)
    ) {
      target.x = nx;
      target.y = ny;
      target.cube = rotateCube(target.cube, dirInput);
      alert(`${player.name} å¼·åˆ¶ç§»å‹• ${target.name} å‘ ${dirInput} è‡³æ ¼å­ ${boardData[ny][nx]}`);
      checkRule1(target);
    } else {
      alert("è©²æ–¹å‘ç„¡æ³•ç§»å‹•æˆ–æ ¼å­è¢«ä½”ç”¨");
    }
  }
}


function move(dir) {
  const player = players[currentPlayerIdx];
  if (!allPlayersReady()) {
    alert("æ‰€æœ‰ç©å®¶å°šæœªè¨­å®šèµ·å§‹ä½ç½®ï¼Œè«‹å…ˆå®Œæˆè¨­å®šã€‚");
    return;
  }


  if (player.x === undefined || player.y === undefined) return;

  const dx = dir === 'left' ? -1 : dir === 'right' ? 1 : 0;
  const dy = dir === 'up' ? -1 : dir === 'down' ? 1 : 0;
  const newX = player.x + dx;
  const newY = player.y + dy;

  if (newX < 0 || newX > 16 || newY < 0 || newY > 16 || boardData[newY][newX] === null) return;

  // æª¢æŸ¥æ˜¯å¦æœ‰å…¶ä»–ç©å®¶åœ¨ç›®æ¨™æ ¼
  const pushedPlayer = players.find(p => p.x === newX && p.y === newY);
  if (pushedPlayer) {
    const pushX = newX + dx;
    const pushY = newY + dy;

    if (
      pushX < 0 || pushX > 16 ||
      pushY < 0 || pushY > 16 ||
      boardData[pushY][pushX] === null ||
      players.some(p => p.x === pushX && p.y === pushY)
    ) {
      alert("ç„¡æ³•æ¨é–‹å…¶ä»–ç©å®¶ï¼Œç§»å‹•å¤±æ•—ã€‚");
      return;
    }

    pushedPlayer.x = pushX;
    pushedPlayer.y = pushY;
    alert(`${pushedPlayer.name} è¢« ${player.name} æ¨åˆ°äº†æ ¼å­ ${boardData[pushY][pushX]}`);

    // ç¬¬ä¸‰æ¢è¦å‰‡ï¼šæ¨é–‹ä¸è§¸ç™¼å…¶ä»–è¦å‰‡ï¼Œä½†ä»æª¢æŸ¥æ˜¯å¦æ”¾é€
    checkRule1(pushedPlayer);
  }

  const nextNum = boardData[newY][newX];
  const cellColor = colorMap[nextNum];
  const newCube = rotateCube(player.cube, dir);


  player.x = newX;
  player.y = newY;
  player.cube = newCube;

  checkRule1(player);

  // ğŸ›¡ï¸ æ”¾é€å›ä¾†çš„é‚£ä¸€è¼ªä¸æª¢æŸ¥è¦å‰‡4/5
  if (player.justBanished) {
    player.justBanished = false; // åªç•¥éé€™ä¸€å›åˆ
  } else {
    checkRule4And5(player);
  }

  checkRule6(player);


  currentPlayerIdx = (currentPlayerIdx + 1) % players.length;
  updateTurnInfo();
  drawBoard();
    }

    function updateTurnInfo() {
      document.getElementById("turnInfo").textContent = "è¼ªåˆ°ã€Œ" + players[currentPlayerIdx].name + "ã€ç§»å‹•ã€‚";
    }

    function drawBoard() {
      const board = document.getElementById("board");
      board.innerHTML = "";
      for (let y = 0; y < 17; y++) {
        for (let x = 0; x < 17; x++) {
          const val = boardData[y][x];
          const cell = document.createElement("div");
          cell.className = "cell";
          if (val !== null && val !== undefined) {
            cell.textContent = String(val);

            const color = colorMap[val];
            if (typeof color === "string") {
              cell.classList.add(color);
            } else {
              cell.classList.add("gray");
            }

            players.forEach(p => {
              if (p.x === x && p.y === y) {
                const div = document.createElement("div");
                div.className = 'playerCube';
                div.innerHTML = `${p.name}<br>${p.cube.top}`;
                cell.appendChild(div);
              }
            });
          } else {
            cell.classList.add('empty');
          }
          board.appendChild(cell);
        }
      }
    }

    function initSelectors() {
      const sel = document.getElementById("playerSelect");
      players.forEach((p, i) => {
        const opt = document.createElement("option");
        opt.value = i;
        opt.textContent = p.name;
        sel.appendChild(opt);
      });
    }

    initSelectors();
    drawBoard();

  </script>
</body>
</html>
